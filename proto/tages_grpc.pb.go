// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: proto/tages.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TagesServiceClient is the client API for TagesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagesServiceClient interface {
	UploadImage(ctx context.Context, opts ...grpc.CallOption) (TagesService_UploadImageClient, error)
	DownloadImage(ctx context.Context, in *Messages, opts ...grpc.CallOption) (TagesService_DownloadImageClient, error)
	ListImage(ctx context.Context, in *NoParam, opts ...grpc.CallOption) (TagesService_ListImageClient, error)
}

type tagesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagesServiceClient(cc grpc.ClientConnInterface) TagesServiceClient {
	return &tagesServiceClient{cc}
}

func (c *tagesServiceClient) UploadImage(ctx context.Context, opts ...grpc.CallOption) (TagesService_UploadImageClient, error) {
	stream, err := c.cc.NewStream(ctx, &TagesService_ServiceDesc.Streams[0], "/tages_service.TagesService/UploadImage", opts...)
	if err != nil {
		return nil, err
	}
	x := &tagesServiceUploadImageClient{stream}
	return x, nil
}

type TagesService_UploadImageClient interface {
	Send(*UploadRequest) error
	CloseAndRecv() (*Messages, error)
	grpc.ClientStream
}

type tagesServiceUploadImageClient struct {
	grpc.ClientStream
}

func (x *tagesServiceUploadImageClient) Send(m *UploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tagesServiceUploadImageClient) CloseAndRecv() (*Messages, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Messages)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tagesServiceClient) DownloadImage(ctx context.Context, in *Messages, opts ...grpc.CallOption) (TagesService_DownloadImageClient, error) {
	stream, err := c.cc.NewStream(ctx, &TagesService_ServiceDesc.Streams[1], "/tages_service.TagesService/DownloadImage", opts...)
	if err != nil {
		return nil, err
	}
	x := &tagesServiceDownloadImageClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TagesService_DownloadImageClient interface {
	Recv() (*SendChunks, error)
	grpc.ClientStream
}

type tagesServiceDownloadImageClient struct {
	grpc.ClientStream
}

func (x *tagesServiceDownloadImageClient) Recv() (*SendChunks, error) {
	m := new(SendChunks)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tagesServiceClient) ListImage(ctx context.Context, in *NoParam, opts ...grpc.CallOption) (TagesService_ListImageClient, error) {
	stream, err := c.cc.NewStream(ctx, &TagesService_ServiceDesc.Streams[2], "/tages_service.TagesService/ListImage", opts...)
	if err != nil {
		return nil, err
	}
	x := &tagesServiceListImageClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TagesService_ListImageClient interface {
	Recv() (*Messages, error)
	grpc.ClientStream
}

type tagesServiceListImageClient struct {
	grpc.ClientStream
}

func (x *tagesServiceListImageClient) Recv() (*Messages, error) {
	m := new(Messages)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TagesServiceServer is the server API for TagesService service.
// All implementations must embed UnimplementedTagesServiceServer
// for forward compatibility
type TagesServiceServer interface {
	UploadImage(TagesService_UploadImageServer) error
	DownloadImage(*Messages, TagesService_DownloadImageServer) error
	ListImage(*NoParam, TagesService_ListImageServer) error
	mustEmbedUnimplementedTagesServiceServer()
}

// UnimplementedTagesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTagesServiceServer struct {
}

func (UnimplementedTagesServiceServer) UploadImage(TagesService_UploadImageServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadImage not implemented")
}
func (UnimplementedTagesServiceServer) DownloadImage(*Messages, TagesService_DownloadImageServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadImage not implemented")
}
func (UnimplementedTagesServiceServer) ListImage(*NoParam, TagesService_ListImageServer) error {
	return status.Errorf(codes.Unimplemented, "method ListImage not implemented")
}
func (UnimplementedTagesServiceServer) mustEmbedUnimplementedTagesServiceServer() {}

// UnsafeTagesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagesServiceServer will
// result in compilation errors.
type UnsafeTagesServiceServer interface {
	mustEmbedUnimplementedTagesServiceServer()
}

func RegisterTagesServiceServer(s grpc.ServiceRegistrar, srv TagesServiceServer) {
	s.RegisterService(&TagesService_ServiceDesc, srv)
}

func _TagesService_UploadImage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TagesServiceServer).UploadImage(&tagesServiceUploadImageServer{stream})
}

type TagesService_UploadImageServer interface {
	SendAndClose(*Messages) error
	Recv() (*UploadRequest, error)
	grpc.ServerStream
}

type tagesServiceUploadImageServer struct {
	grpc.ServerStream
}

func (x *tagesServiceUploadImageServer) SendAndClose(m *Messages) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tagesServiceUploadImageServer) Recv() (*UploadRequest, error) {
	m := new(UploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TagesService_DownloadImage_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Messages)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TagesServiceServer).DownloadImage(m, &tagesServiceDownloadImageServer{stream})
}

type TagesService_DownloadImageServer interface {
	Send(*SendChunks) error
	grpc.ServerStream
}

type tagesServiceDownloadImageServer struct {
	grpc.ServerStream
}

func (x *tagesServiceDownloadImageServer) Send(m *SendChunks) error {
	return x.ServerStream.SendMsg(m)
}

func _TagesService_ListImage_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NoParam)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TagesServiceServer).ListImage(m, &tagesServiceListImageServer{stream})
}

type TagesService_ListImageServer interface {
	Send(*Messages) error
	grpc.ServerStream
}

type tagesServiceListImageServer struct {
	grpc.ServerStream
}

func (x *tagesServiceListImageServer) Send(m *Messages) error {
	return x.ServerStream.SendMsg(m)
}

// TagesService_ServiceDesc is the grpc.ServiceDesc for TagesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tages_service.TagesService",
	HandlerType: (*TagesServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadImage",
			Handler:       _TagesService_UploadImage_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadImage",
			Handler:       _TagesService_DownloadImage_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListImage",
			Handler:       _TagesService_ListImage_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/tages.proto",
}
